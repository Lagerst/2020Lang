# DataBase

    varchar(n)
        Capacity < 5.0.3 ? Unit = 字节 :(else) Unit = 字符

## 索引

    目录页 - 页目录 - 页 - 二分法
    根据 主键 - (if null) 唯一索引 - (if null) 默认生成rowid 建立 B+树

    建议自增id作为主键，提升存储效率（使用更少的页作为索引）

    建立过程

        第一页

        copy第一页 -> 开辟第二页，第一页改为目录页（起始页不变）

    辅助索引

        create index idx_t_bcd on t(b, c, d) 联合索引，按序排序
        辅助索引找到后回到主键索引取数据 或 全表暴力搜索

        explain关键字

    比较规则

        bin, 字符集......

    使用索引

        最左前缀原则

## 事务4大特性 mysql如何保证实现

    Atomicity 原子性
        一系列操作要么都成功，要么都失败

    Isolation 隔离型
        事务之间相互隔离，互不影响

    Consistency
        总数据的一致性，总数据保持既定的约束

    Durability
        记录永久保存

    事务

        autocommit 事务自动提交

        START TRANSACTION;
        ...
        commit;

    隐式提交

        特定语句执行会自动commit (定义或修改数据库对象的数据定义语言)
        ALTER TABLE, CREATE USER, DROP USER, GRANT, RENAME USER, SET PASSWORD,
        LOCK TABLES, UNLOCK TABLES,
        LOAD DATA,
        ANALYZE TABLE, CACHE INDEX, CHECK TABLE, FLUSH, LOAD INDEX INTO CACHE, OPTIMIZE TABLE

    保存点

        只回滚到保存点

        SAVEPOINT 保存点名称;
        ROLLBACK [WORK] TO [SAVEPOINT] 保存点名称;
        RELEASE SAVEPOINT 保存点名称;

## 事务隔离级别

## Mysql默认隔离级别与并发安全

## RR和RC如何实现 使用场景

## 隔离级别的单位

## 存储引擎Innodb和Myisam

    Innodb page size default = 16384/1024 = 16KB
    Row Format :
        Dynamic
            完全的行溢出的方式，在数据页中只存放20个字节的指针，指向下一页地址

        Compact
            变长字段长度列表 NULL标志位 记录头信息 列1 列2 ...
            2 Bytes         1 Byte    max to 65532Bytes

            Optional:
                部分数据 + 下一页地址

## Innodb锁机制，行锁，表锁，意向锁
    https://blog.csdn.net/qq_41008202/article/details/105488111
### 锁协议
    在介绍锁之前，我先介绍下锁协议，为了进行并发控制，数据库的锁协议主要有两种，一种是封锁协议，另外一个是两段锁协议；封锁协议规定了何时加锁和该加什么锁以及何时释放锁的规则，而两段锁协议除了规定做相应操作前加相应的锁，更是严格的将事务的整个过程分成加锁阶段和解锁阶段两个过程，加锁阶段不能进行解锁，解锁过程不能加锁。

### 封锁协议
    封锁协议规定了何时加锁、释放锁的规则，不同的规则可用于实现不同的隔离级别，解决不同的并发事务问题。(X锁即为排他锁，S锁即为共享锁，对X锁和S锁不了解的可以滑动到下面先进行了解)

    一级封锁协议：更新数据前需要先加X锁，直到事务结束才释放X锁，读数据是不需要加S锁。所以只能解决第一类更新丢失问题，不能解决脏读和不可重复读等问题。

    二级封锁协议：在一级封锁的基础上，事务在读取数据之前必须先对其加上S锁，读完即可释放S锁。可以解决第一类更新丢失问题和脏读。

    三级封锁协议：一级封锁协议的基础上，事务在读取数据之前必须先对其加S锁，直到事务结束才释放。解决了丢失修改、脏读和不可重复读的问题。

## MVCC

## 哈希索引

    哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

    对于hash相同的，采用链表的方式解决冲突。类似于hashmap。因为索引的结构是十分紧凑的，所以hash索引的查询很快。

    只支持等值比较查询，不支持任何范围查询。不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。数据并不是按照索引值顺序存储的，所以也就无法用于排序

    在Mysql中InnoDB引擎有一个特殊的功能叫做自适应哈希索引，它会在内存中基于B-Tree索引的基础上面创建一个哈希索引，这让B-Tree索引具备了一些哈希索引的优点

## B树索引为什么使用B+树，相对于B树有什么优点？为什么不能红黑树？

磁盘预读

## 聚簇索引和非聚簇索引

    聚簇索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。
    索引和数据是否在同一个文件，索引的逻辑顺序与磁盘上行的物理存储顺序是否相同

    聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。

    优点：
　　　　1.数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快
　　　　2.聚簇索引对于主键的排序查找和范围查找速度非常快
　　 缺点：
　　　　1.插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个自增的ID列为主键
　　　　2.更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。
　　　　3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。

    在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。

## 创建索引

    CREATE INDEX index_name ON table_name (column_name)

## 使用索引避免全表扫描

    Pass

## Explain语句各字段的意义

    explain可以分析某条select语句会查询多少条记录、以怎样的方式查询，以及复杂select的执行顺序，借此可以了解到select语句的性能和查询是如何执行的

## 联合索引优化 最左前缀

    Pass

## 数据库范式

    第一范式（1NF） 去除复合属性和多值属性
    关系表 R 不存在复合属性和多值属性
    
    第二范式（2NF） 去除非主属性的部分函数依赖
    关系表 R 满足 1NF，且所有非主属性都完全依赖于任一候选键

    第三范式（3NF） 去除非主属性的传递函数依赖
    关系表 R 满足 2NF，且所有非主属性都非传递依赖于任一候选键
    
    巴斯-科德范式（BCNF） 去除主属性对键的部分函数依赖或传递函数依赖
    关系表 R 满足 3NF，且 R 的任意函数依赖的左部都是 R 的一个候选键
    
    第四范式(4NF） 去除非平凡多值依赖
    关系表 R 满足 1NF，且 R 的任意非平凡的多值依赖 x ->-> y(x不包含y), x含有键
    
    第五范式（5NF，又称完美范式）

## 数据库查询关键字

    between     显示在某一区间的值
    in          显示某一属性的多个值
    like        模糊查询 通配符
    ASC         升序，默认值   
      DESC      降序
    聚合函数     五个聚合函数（max() min() avg() count() sum()）
    GROUP BY    分组查询：将相同的数据分为一组。
    limit       LIMIT 是限制的意思，所以 LIMIT 的作用就是限制查询记录的条数

## mysql主从复制过程，binlog记录格式，复制的异步半同步同步模式区别

## 主从复制或读写分离等数据不一致性问题